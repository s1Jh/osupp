/*******************************************************************************
 * Copyright (c) 2022 sijh (s1Jh.199[at]gmail.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ******************************************************************************/

/*====================================================================================================================*/
/*  Curve.dpp */
/*                                                                                                                    */
/*  Declarations of the parametric curve template library. */
/*                                                                                                                    */
/*  Last edited: 7.6.2022 */
/*                                                                                                                    */
/*--------------------------------------------------------------------------------------------------------------------*/
#pragma once

/*====================================================================================================================*/
/*  Depends on project config, the types library and C++20+ */
/*--------------------------------------------------------------------------------------------------------------------*/
#include "Vec2.hpp"
#include "define.hpp"

#include <concepts>
#include <type_traits>

/*====================================================================================================================*/
/*  Begin declarations */
/*--------------------------------------------------------------------------------------------------------------------*/
NS_BEGIN

enum class CurveType
{
    BEZIER, STRAIGHT, CATMULL, SEMI_CIRCLE, CIRCLE
};

/*====================================================================================================================*/
/*  The curve node type which will be used in calculations. A virtual
 * getPosition() method is declared.               */
/*  All types which the user wants to be recognized as valid curve points must
 * implement this method.                 */
/*  This is done instead of declaring a position variable to let the user decide
 * how they wish to store               */
/*  their node position. */
/*--------------------------------------------------------------------------------------------------------------------*/
struct BaseCurveNode
{
    [[nodiscard]] virtual fvec2d getPosition() const;
};

/*====================================================================================================================*/
/*  Helper concept used to determine whether a type is inherited from
 * BaseCurveNode, but is not BaseCurveNode itself. */
/*--------------------------------------------------------------------------------------------------------------------*/
template<typename T>
concept IsInheritedCurve = std::is_base_of_v<BaseCurveNode, T> and
    not std::is_same_v<T, BaseCurveNode>;

template<typename T>
concept IsCurveIterator = std::forward_iterator<T> and
    IsInheritedCurve<typename std::iterator_traits<T>::value_type>;

struct CurveNode: public BaseCurveNode
{
    CurveNode(fvec2d _position);

    fvec2d position;

    [[nodiscard]] fvec2d getPosition() const override;
};

template<CurveType CType>
struct CurveCalculationFunctor
{
};

template<typename IteratorT, typename LengthT = double> requires IsCurveIterator<IteratorT>
    and std::floating_point<LengthT>
struct Curve
{
    explicit Curve();

    Curve(IteratorT _begin, IteratorT _end);

    void setIteratorRange(IteratorT _begin, IteratorT _end);

    void update();

    template<CurveType Type, typename TType>
    requires std::floating_point<TType>
    [[nodiscard]] vec2d<TType> get(TType t) const;

    template<typename TType>
    requires std::floating_point<TType>
    [[nodiscard]] vec2d<TType> get(CurveType type, TType t) const;

    [[nodiscard]] IteratorT getBegin() const;

    [[nodiscard]] IteratorT getEnd() const;

    [[nodiscard]] LengthT getLength() const;

protected:
    IteratorT begin, end;
    LengthT length;
};

template<>
struct CurveCalculationFunctor<CurveType::STRAIGHT>
{
    template<typename TType, typename IteratorT, typename LengthT = double>
    requires std::floating_point<TType> and IsCurveIterator<IteratorT> and
        std::floating_point<LengthT>
    static vec2d<TType> calculate(const Curve<IteratorT, LengthT> &curve,
                                  TType t);
};

template<>
struct CurveCalculationFunctor<CurveType::BEZIER>
{
    template<typename TType, typename IteratorT, typename LengthT = double>
    requires std::floating_point<TType> and IsCurveIterator<IteratorT> and
        std::floating_point<LengthT>
    static vec2d<TType> calculate(const Curve<IteratorT, LengthT> &curve,
                                  TType t);
};

template<>
struct CurveCalculationFunctor<CurveType::CATMULL>
{
    template<typename TType, typename IteratorT, typename LengthT = double>
    requires std::floating_point<TType> and IsCurveIterator<IteratorT> and
        std::floating_point<LengthT>
    static vec2d<TType> calculate(const Curve<IteratorT, LengthT> &curve,
                                  TType t);
};

template<>
struct CurveCalculationFunctor<CurveType::CIRCLE>
{
    template<typename TType, typename IteratorT, typename LengthT = double>
    requires std::floating_point<TType> and IsCurveIterator<IteratorT> and
        std::floating_point<LengthT>
    static vec2d<TType> calculate(const Curve<IteratorT, LengthT> &curve,
                                  TType t);
};

template<>
struct CurveCalculationFunctor<CurveType::SEMI_CIRCLE>
{
    template<typename TType, typename IteratorT, typename LengthT = double>
    requires std::floating_point<TType> and IsCurveIterator<IteratorT> and
        std::floating_point<LengthT>
    static vec2d<TType> calculate(const Curve<IteratorT, LengthT> &curve,
                                  TType t);
};

/*====================================================================================================================*/
/*  Specializations of the Curve struct. */
/*--------------------------------------------------------------------------------------------------------------------*/

NS_END